# AGENTS.md

This file provides guidance to AI coding assistants (including WARP) when working with code in this repository.

## Project overview

HashHive is a 2026 TypeScript reimplementation of [CipherSwarm](https://github.com/unclesp1d3r/CipherSwarm), a distributed hash cracking management system originally built on Ruby on Rails with PostgreSQL. It orchestrates hashcat across multiple agents in a private lab environment (7 cracking rigs), providing:

- Agent management and monitoring
- Campaign and attack orchestration with DAG-based dependencies
- Task distribution over a shared keyspace
- Resource management for hash lists, wordlists, rulelists, and masklists
- Real-time dashboards for agents, campaigns, and crack results
- Project-scoped multi-tenancy and role-based access control

**Production context:** This system runs in a private lab, not publicly exposed. The agent API handles periodic bursts when rigs submit cracked hashes, request work units, and send heartbeats. The web dashboard serves 1-3 concurrent human users. Optimize for correctness, clarity, and developer experience — not premature scale.

## Repository layout

High-level monorepo structure (see `.kiro/steering/structure.md` for the authoritative layout):

```text
/
├── packages/
│   ├── backend/          # Bun + Hono API
│   │   ├── src/
│   │   │   ├── routes/       # Hono route handlers by domain
│   │   │   │   ├── agent/    # Agent API routes (/api/v1/agent/*)
│   │   │   │   └── dashboard/# Dashboard API routes (/api/v1/dashboard/*)
│   │   │   ├── db/           # Drizzle client setup, connection config
│   │   │   ├── middleware/   # Hono middleware (auth, logging, etc.)
│   │   │   └── services/     # Business logic (optional, only when needed)
│   │   ├── tests/
│   │   │   ├── unit/         # Service and utility tests
│   │   │   └── integration/  # API tests
│   │   ├── drizzle.config.ts # Drizzle Kit configuration
│   │   └── package.json
│   │
│   ├── frontend/         # React 19 + Vite UI
│   │   ├── src/
│   │   │   ├── components/   # React components
│   │   │   │   ├── ui/       # shadcn/ui base components
│   │   │   │   └── features/ # Feature-specific components
│   │   │   ├── pages/        # Route-level page components
│   │   │   ├── lib/          # Utilities and API client config
│   │   │   ├── hooks/        # Custom React hooks (TanStack Query wrappers)
│   │   │   └── stores/       # Zustand stores for UI state
│   │   └── package.json
│   │
│   ├── shared/           # Shared Drizzle schema, Zod schemas, and types
│   │   ├── src/
│   │   │   ├── db/
│   │   │   │   ├── schema.ts     # Drizzle table definitions (source of truth)
│   │   │   │   └── migrations/   # Generated by drizzle-kit
│   │   │   ├── schemas/      # Zod schemas (drizzle-zod + custom)
│   │   │   └── types/        # Inferred types (z.infer exports)
│   │   └── package.json
│   │
│   └── openapi/          # API specifications
│       └── agent-api.yaml    # Agent API OpenAPI spec
│
├── docs/                 # Documentation
│   ├── MERN_proposal.md
│   └── v2_rewrite_implementation_plan/
│
├── .kiro/                # Product/tech steering and specs (authoritative design)
│   ├── steering/
│   │   ├── product.md
│   │   ├── structure.md
│   │   └── tech.md
│   └── specs/
│       └── mern-migration/
│           ├── requirements.md
│           ├── design.md
│           └── tasks.md
│
├── turbo.json            # Turborepo configuration
└── package.json          # Root package.json (Bun workspace)
```

When adding new modules or services, follow this monorepo layout. Hono route handlers can call Drizzle queries directly — only introduce service layers when handlers become complex.

## Technology stack

- **Runtime**: Bun (latest stable) — JavaScript runtime, package manager, and test runner
- **Backend framework**: Hono running natively on `Bun.serve()` (not Express, not Fastify)
- **Database**: PostgreSQL with Drizzle ORM (primary data store)
- **Task Queue**: Redis + BullMQ for async processing (hash list parsing, task generation, heartbeat monitoring)
- **Storage**: MinIO (S3-compatible) for binary artifacts (hash lists, wordlists, rulelists, masklists)
- **Frontend**: React 19 + Vite (not Next.js, not CRA)
- **UI**: Tailwind CSS + shadcn/ui components
- **State**: TanStack Query v5 for server state, Zustand for client-side UI state
- **Monorepo**: Turborepo with Bun workspaces (not Nx, not Lerna)
- **Linting/Formatting**: Biome (not ESLint, not Prettier)
- **Testing**: bun:test for all tests, Testing Library for components, Playwright for E2E

See `.kiro/steering/tech.md` for the full-stack details and `spec/epic/specs/Tech_Plan__HashHive_Architecture.md` for architectural principles.

## Architectural big picture

### Schema flow (single source of truth)

Drizzle table definitions → drizzle-zod → Zod schemas → TypeScript types. One direction, no duplication.

When backend route validation changes (e.g., removing a field), update the corresponding shared Zod schema in `shared/src/schemas/index.ts` — the frontend imports these types via `@hashhive/shared`.

- **Drizzle tables** in `shared/src/db/schema.ts` define the database schema and generate migrations
- **drizzle-zod** generates Zod schemas from Drizzle tables for API validation
- **z.infer** derives TypeScript types from Zod schemas — no manually duplicated interfaces

### Backend architecture

The backend is a Bun + Hono + TypeScript service:

- **Routes (`src/routes/`)**
  - HTTP endpoints grouped by API surface: Agent API, Dashboard API
  - Thin handlers: parse/validate input with Zod, call Drizzle queries or service layer, return responses
- **Services (`src/services/`)** — optional, only when route handlers become complex
  - **Circular import note:** `campaigns.ts` and `tasks.ts` have a circular dependency. Resolved via dynamic `await import('./tasks.js')` in campaigns.ts. Maintain this pattern when adding cross-service calls.
  - `AuthService`: login/logout, JWT/session management
  - `AgentService`: registration, capability detection, heartbeat handling
  - `CampaignService`: campaign lifecycle, DAG validation, attack configuration
  - `TaskDistributionService`: keyspace partitioning, task generation, assignment
  - `ResourceService`: file uploads to MinIO, hash list parsing coordination
  - `HashAnalysisService`: hash-type identification, hashcat mode mapping
  - `EventService`: WebSocket broadcasting for real-time dashboard updates (in-memory v1, Redis pub/sub extension path)
- **Database (`src/db/`)** — Drizzle client setup and connection config
- **Middleware (`src/middleware/`)** — auth, validation, error handling

### RBAC middleware

Two RBAC middleware variants in `src/middleware/rbac.ts`:
- `requireProjectAccess()` / `requireRole()` — reads projectId from JWT context (`currentUser.projectId`); used by most dashboard routes
- `requireParamProjectAccess()` / `requireParamProjectRole()` — reads projectId from URL param (`c.req.param('projectId')`); used by project management routes like `GET /projects/:projectId`

### API surfaces

Two API surfaces on the same Hono instance, backed by the same service and data layer:

- **Agent API (`/api/v1/agent/*`)**
  - Pre-shared token authenticated REST API for Go-based hashcat agents
  - Defined by `openapi/agent-api.yaml` (single source of truth for contract)
  - Supports batch operations: bulk inserts for hash submissions via Drizzle or raw `Bun.SQL`
  - Core endpoints: `POST /agent/heartbeat`, `POST /agent/tasks/next`, `POST /agent/tasks/:id/report`
- **Dashboard API (`/api/v1/dashboard/*`)**
  - JWT + HttpOnly session cookie authenticated REST API for the React frontend
  - Project scoping is JWT-bound: `projectId` is embedded in the session token and read from `c.get('currentUser').projectId` — frontend never sends projectId as a query param
  - Standard CRUD operations with Zod validation
  - Low traffic (1-3 concurrent users)

Agent API contract tests should validate responses against the OpenAPI spec to keep server and clients in sync.

### Frontend architecture

The frontend is a Vite + React 19 SPA (no server components, no meta-framework):

- **TanStack Query mutations**: Use `onSuccess(_data, variables)` for cache invalidation keys, not Zustand store state (can be stale)
- Tailwind CSS and shadcn/ui for UI components
- Forms built with React Hook Form + Zod schemas from the `shared/` package
- Data fetching and caching via TanStack Query
- Real-time updates delivered via WebSocket client (with polling fallback on disconnect)
- Zustand for client-side UI state (project selection, filters, wizard state)

### Data model (PostgreSQL tables)

- **Identity & access**: `users`, `projects`, `project_users` (roles as text array)
- **Agents & telemetry**: `operating_systems`, `agents`, `agent_errors`
- **Campaign orchestration**: `campaigns`, `attacks` (with DAG dependencies), `tasks` (work ranges, progress, results)
  - Campaign lifecycle: `draft` → `running` → `paused` / `completed` / `cancelled`. Stop action returns to `draft` (not `completed`). Start requires ≥1 attack.
  - `hash_items` has unique constraint on `(hashListId, hashValue)` — use `onConflictDoUpdate` for crack result attribution
- **Resources**: `hash_lists`, `hash_items`, `hash_types`, `word_lists`, `rule_lists`, `mask_lists`

## Development commands

Commands are run from the workspace root using Bun and Turborepo:

```bash
# Workspace filters use package.json names — `@hashhive/shared`, `@hashhive/backend`, `@hashhive/frontend`
# Shorthand like `bun --filter shared` may fail; use full name: `bun --filter @hashhive/shared build`

# Development
bun dev                          # Start all services via Turborepo
bun --filter backend dev         # Start backend only
bun --filter frontend dev        # Start frontend only

# Testing
bun test                         # Run all tests via Turborepo
bun --filter backend test        # Run backend tests (bun:test)
bun --filter frontend test       # Run frontend tests
bun test:e2e                     # Run Playwright E2E tests

# Building & linting
bun build                        # Build all packages via Turborepo
bun lint                         # Lint all code with Biome
bun format                       # Format all code with Biome
bun type-check                   # TypeScript type checking

# Database
bun --filter backend db:generate # Generate Drizzle migrations
bun --filter backend db:migrate  # Run migrations
bun --filter backend db:studio   # Open Drizzle Studio
```

### Local CI check

```bash
just ci-check    # Runs: lint → format-check → type-check → build → test (no Docker needed)
```

## Testing strategy

- **bun:test** for all tests (Bun's built-in test runner — not Jest, not Vitest)
- **Backend unit tests**: Service logic, utilities, validation schemas
- **Backend integration tests**: API endpoints with test database
- **Frontend component tests**: Testing Library for React components
- **E2E tests**: Playwright for complete user workflows
- **Contract tests**: Validate Agent API responses against the OpenAPI spec

Test the hot paths first: hash submission ingestion, work unit distribution, agent heartbeat processing.

## Design and documentation sources

`.kiro/steering/` and `.kiro/specs/` are the **authoritative** sources for architecture, requirements, and constraints. When code conflicts with these documents, the documents win. Update the docs first if behavior needs to change.

### Authoritative (`.kiro/`)

- `.kiro/steering/product.md` — product overview and core capabilities
- `.kiro/steering/structure.md` — repository structure, table list, and API routes
- `.kiro/steering/tech.md` — technology stack, commands, key libraries, and "what NOT to introduce"
- `.kiro/specs/mern-migration/requirements.md` — detailed functional requirements
- `.kiro/specs/mern-migration/design.md` — end-to-end architecture and data models
- `.kiro/specs/mern-migration/tasks.md` — implementation task breakdown

### Epic specifications (`spec/epic/`)

- `spec/epic/specs/Epic_Brief__HashHive_-_Modern_Distributed_Password_Cracking_Platform.md` — epic-level product brief
- `spec/epic/specs/Tech_Plan__HashHive_Architecture.md` — comprehensive technical architecture and design decisions
- `spec/epic/specs/Core_Flows__HashHive_User_Journeys.md` — user flows, wireframes, and UI specifications
- `spec/epic/tickets/` — feature-level implementation tickets

### Supplementary

- `docs/v2_rewrite_implementation_plan/*` — historical context from CipherSwarm migration

## TypeScript strict mode gotchas

The tsconfig.base.json enables maximum strictness. Key patterns:

- **`exactOptionalPropertyTypes`**: Use `...(val ? { key: val } : {})` spread, never `key: val ?? undefined`
- **`noUncheckedIndexedAccess`**: All `arr[i]` returns `T | undefined` — guard with null check before use
- **`noPropertyAccessFromIndexSignature`**: Use `obj['key']` bracket notation for index signatures
- **Biome `useLiteralKeys: "off"`**: MUST stay off — conflicts with the TS setting above
- **`z.preprocess` + React Hook Form**: `z.preprocess` widens input type to `unknown`, breaking `zodResolver` under strict mode. Define the form type as an explicit interface (not `z.infer`) and cast: `zodResolver(schema) as unknown as Resolver<FormType>`

## Hono error handling

The `app.onError()` handler must check `instanceof HTTPException` before returning a generic 500:

```typescript
app.onError((err, c) => {
  if (err instanceof HTTPException) return err.getResponse();
  // ... generic error handling
});
```

Without this, auth middleware 401 responses get swallowed into 500s.

## Testing infrastructure

- Backend contract tests validate auth (401) and validation (400) without a running DB
- Drizzle mock chains must match production code — e.g. `insert().values()` returning `{ onConflictDoNothing: mock() }`
- BullMQ worker test mocks: if worker does `db.select()`, mock must return chainable `{ from: mock(() => chain), where: mock(() => Promise.resolve([])) }`
- Frontend tests use `happy-dom` with manual global injection (not `@happy-dom/global-registrator`)
- Always call `afterEach(cleanup)` in Testing Library tests — DOM persists in happy-dom
- Test fixtures: `packages/backend/tests/fixtures.ts` — factory functions + token helpers
- Biome overrides: `**/scripts/**` disables `noConsole` and `noExplicitAny` for CLI tools

### Frontend test utilities

- `tests/mocks/fetch.ts` — `mockFetch()` replaces global fetch with route-to-response mapping; call `restoreFetch()` in afterEach
- `tests/mocks/websocket.ts` — `installMockWebSocket()` replaces global WebSocket; provides `simulateOpen/Close/Message`
- `tests/fixtures/api-responses.ts` — factory functions: `mockLoginResponse`, `mockMeResponse`, `mockDashboardStats`
- `tests/utils/store-reset.ts` — `resetAllStores()` resets all Zustand stores; call in afterEach
- `tests/test-utils.tsx` — `renderWithProviders()` (single component), `renderWithRouter()` (navigation tests), `cleanupAll()` (DOM + stores)
- **401 gotcha**: `api.ts` globally intercepts all 401 responses as "Session expired" — login tests must use 400 for invalid credentials
- `@testing-library/user-event` is NOT installed — use `fireEvent` from `@testing-library/react`
- **Run tests per-package**: Use `bun --filter @hashhive/frontend test` / `bun --filter @hashhive/backend test` — root `bun test` skips per-package `bunfig.toml` (happy-dom), causing `document is not defined`

## AI agent notes

- `.kiro/steering/` and `.kiro/specs/` are authoritative — always align structural changes with those documents rather than inferring architecture solely from current code.
- `.kiro/steering/tech.md` contains explicit constraints on what NOT to introduce. Respect these constraints.
- Prefer mermaid diagrams for architectural or sequence diagrams in documentation.
- Agents are the primary API consumer. Never break the agent API to improve the dashboard experience.
