# AGENTS.md

This file provides guidance to AI coding assistants (including WARP) when working with code in this repository.

## Project overview

HashHive is a 2026 TypeScript reimplementation of [CipherSwarm](https://github.com/unclesp1d3r/CipherSwarm), a distributed hash cracking management system originally built on Ruby on Rails with PostgreSQL. It orchestrates hashcat across multiple agents in a private lab environment (7 cracking rigs), providing:

- Agent management and monitoring
- Campaign and attack orchestration with DAG-based dependencies
- Task distribution over a shared keyspace
- Resource management for hash lists, wordlists, rulelists, and masklists
- Real-time dashboards for agents, campaigns, and crack results
- Project-scoped multi-tenancy and role-based access control

**Production context:** This system runs in a private lab, not publicly exposed. The agent API handles periodic bursts when rigs submit cracked hashes, request work units, and send heartbeats. The web dashboard serves 1-3 concurrent human users. Optimize for correctness, clarity, and developer experience — not premature scale.

## Repository layout

High-level monorepo structure (see `.kiro/steering/structure.md` for the authoritative layout):

```text
/
├── packages/
│   ├── backend/          # Bun + Hono API
│   │   ├── src/
│   │   │   ├── routes/       # Hono route handlers by domain
│   │   │   │   ├── agent/    # Agent API routes (/api/v1/agent/*)
│   │   │   │   └── dashboard/# Dashboard API routes (/api/v1/dashboard/*)
│   │   │   ├── db/           # Drizzle client setup, connection config
│   │   │   ├── middleware/   # Hono middleware (auth, logging, etc.)
│   │   │   └── services/     # Business logic (optional, only when needed)
│   │   ├── tests/
│   │   │   ├── unit/         # Service and utility tests
│   │   │   └── integration/  # API tests
│   │   ├── drizzle.config.ts # Drizzle Kit configuration
│   │   └── package.json
│   │
│   ├── frontend/         # React 19 + Vite UI
│   │   ├── src/
│   │   │   ├── components/   # React components
│   │   │   │   ├── ui/       # shadcn/ui base components
│   │   │   │   └── features/ # Feature-specific components
│   │   │   ├── pages/        # Route-level page components
│   │   │   ├── lib/          # Utilities and API client config
│   │   │   ├── hooks/        # Custom React hooks (TanStack Query wrappers)
│   │   │   └── stores/       # Zustand stores for UI state
│   │   └── package.json
│   │
│   ├── shared/           # Shared Drizzle schema, Zod schemas, and types
│   │   ├── src/
│   │   │   ├── db/
│   │   │   │   ├── schema.ts     # Drizzle table definitions (source of truth)
│   │   │   │   └── migrations/   # Generated by drizzle-kit
│   │   │   ├── schemas/      # Zod schemas (drizzle-zod + custom)
│   │   │   └── types/        # Inferred types (z.infer exports)
│   │   └── package.json
│   │
│   └── openapi/          # API specifications
│       └── agent-api.yaml    # Agent API OpenAPI spec
│
├── docs/                 # Documentation
│   ├── MERN_proposal.md
│   └── v2_rewrite_implementation_plan/
│
├── .kiro/                # Product/tech steering and specs (authoritative design)
│   ├── steering/
│   │   ├── product.md
│   │   ├── structure.md
│   │   └── tech.md
│   └── specs/
│       └── mern-migration/
│           ├── requirements.md
│           ├── design.md
│           └── tasks.md
│
├── turbo.json            # Turborepo configuration
└── package.json          # Root package.json (Bun workspace)
```

When adding new modules or services, follow this monorepo layout. Hono route handlers can call Drizzle queries directly — only introduce service layers when handlers become complex.

## Technology stack

- **Runtime**: Bun (latest stable) — JavaScript runtime, package manager, and test runner
- **Backend framework**: Hono running natively on `Bun.serve()` (not Express, not Fastify)
- **Database**: PostgreSQL with Drizzle ORM (sole data store — no Redis, no MongoDB)
- **Frontend**: React 19 + Vite (not Next.js, not CRA)
- **UI**: Tailwind CSS + shadcn/ui components
- **State**: TanStack Query v5 for server state, Zustand for client-side UI state
- **Monorepo**: Turborepo with Bun workspaces (not Nx, not Lerna)
- **Linting/Formatting**: Biome (not ESLint, not Prettier)
- **Testing**: bun:test for all tests, Testing Library for components, Playwright for E2E

See `.kiro/steering/tech.md` for the full stack details and `MERN_GUIDANCE.md` for architectural principles and constraints.

## Architectural big picture

### Schema flow (single source of truth)

Drizzle table definitions → drizzle-zod → Zod schemas → TypeScript types. One direction, no duplication.

- **Drizzle tables** in `shared/src/db/schema.ts` define the database schema and generate migrations
- **drizzle-zod** generates Zod schemas from Drizzle tables for API validation
- **z.infer** derives TypeScript types from Zod schemas — no manually duplicated interfaces

### Backend architecture

The backend is a Bun + Hono + TypeScript service:

- **Routes (`src/routes/`)**
  - HTTP endpoints grouped by API surface: Agent API, Dashboard API
  - Thin handlers: parse/validate input with Zod, call Drizzle queries or service layer, return responses
- **Services (`src/services/`)** — optional, only when route handlers become complex
  - `AuthService`: login/logout, JWT/session management
  - `AgentService`: registration, capability detection, heartbeat handling
  - `CampaignService`: campaign lifecycle, DAG validation, attack configuration
  - `TaskDistributionService`: keyspace partitioning, task generation, assignment
  - `ResourceService`: file uploads, hash list parsing
  - `HashAnalysisService`: hash-type identification, hashcat mode mapping
  - `EventService`: WebSocket broadcasting for real-time dashboard updates
- **Database (`src/db/`)** — Drizzle client setup and connection config
- **Middleware (`src/middleware/`)** — auth, validation, error handling

### API surfaces

Two API surfaces on the same Hono instance, backed by the same service and data layer:

- **Agent API (`/api/v1/agent/*`)**
  - Token-authenticated REST API for Go-based hashcat agents
  - Defined by `openapi/agent-api.yaml` (single source of truth for contract)
  - Supports batch operations: bulk inserts for hash submissions via Drizzle or raw `Bun.SQL`
  - Core endpoints: `POST /agent/sessions`, `POST /agent/heartbeat`, `POST /agent/tasks/next`, `POST /agent/tasks/:id/report`
- **Dashboard API (`/api/v1/dashboard/*`)**
  - Session-authenticated REST API for the React frontend
  - Standard CRUD operations with Zod validation
  - Low traffic (1-3 concurrent users)

Agent API contract tests should validate responses against the OpenAPI spec to keep server and clients in sync.

### Frontend architecture

The frontend is a Vite + React 19 SPA (no server components, no meta-framework):

- Tailwind CSS and shadcn/ui for UI components
- Forms built with React Hook Form + Zod schemas from the `shared/` package
- Data fetching and caching via TanStack Query
- Real-time updates delivered via WebSocket/SSE client
- Zustand for client-side UI state (selected agents, filters, dashboard layout)

### Data model (PostgreSQL tables)

- **Identity & access**: `users`, `projects`, `project_users`, `roles`
- **Agents & telemetry**: `operating_systems`, `agents`, `agent_errors`
- **Campaign orchestration**: `campaigns`, `attacks` (with DAG dependencies), `tasks` (work ranges, progress, results)
- **Resources**: `hash_lists`, `hash_items`, `hash_types`, `word_lists`, `rule_lists`, `mask_lists`

## Development commands

Commands are run from the workspace root using Bun and Turborepo:

```bash
# Development
bun dev                          # Start all services via Turborepo
bun --filter backend dev         # Start backend only
bun --filter frontend dev        # Start frontend only

# Testing
bun test                         # Run all tests via Turborepo
bun --filter backend test        # Run backend tests (bun:test)
bun --filter frontend test       # Run frontend tests
bun test:e2e                     # Run Playwright E2E tests

# Building & linting
bun build                        # Build all packages via Turborepo
bun lint                         # Lint all code with Biome
bun format                       # Format all code with Biome
bun type-check                   # TypeScript type checking

# Database
bun --filter backend db:generate # Generate Drizzle migrations
bun --filter backend db:migrate  # Run migrations
bun --filter backend db:studio   # Open Drizzle Studio
```

## Testing strategy

- **bun:test** for all tests (Bun's built-in test runner — not Jest, not Vitest)
- **Backend unit tests**: Service logic, utilities, validation schemas
- **Backend integration tests**: API endpoints with test database
- **Frontend component tests**: Testing Library for React components
- **E2E tests**: Playwright for complete user workflows
- **Contract tests**: Validate Agent API responses against the OpenAPI spec

Test the hot paths first: hash submission ingestion, work unit distribution, agent heartbeat processing.

## Design and documentation sources

`.kiro/steering/` and `.kiro/specs/` are the **authoritative** sources for architecture, requirements, and constraints. When code conflicts with these documents, the documents win. Update the docs first if behavior needs to change.

### Authoritative (`.kiro/`)

- `.kiro/steering/product.md` — product overview and core capabilities
- `.kiro/steering/structure.md` — repository structure, table list, and API routes
- `.kiro/steering/tech.md` — technology stack, commands, key libraries, and "what NOT to introduce"
- `.kiro/specs/mern-migration/requirements.md` — detailed functional requirements
- `.kiro/specs/mern-migration/design.md` — end-to-end architecture and data models
- `.kiro/specs/mern-migration/tasks.md` — implementation task breakdown

### Supplementary

- `docs/v2_rewrite_implementation_plan/*` — historical context from CipherSwarm migration

## TypeScript strict mode gotchas

The tsconfig.base.json enables maximum strictness. Key patterns:

- **`exactOptionalPropertyTypes`**: Use `...(val ? { key: val } : {})` spread, never `key: val ?? undefined`
- **`noUncheckedIndexedAccess`**: All `arr[i]` returns `T | undefined` — guard with null check before use
- **`noPropertyAccessFromIndexSignature`**: Use `obj['key']` bracket notation for index signatures
- **Biome `useLiteralKeys: "off"`**: MUST stay off — conflicts with the TS setting above

## Hono error handling

The `app.onError()` handler must check `instanceof HTTPException` before returning a generic 500:
```typescript
app.onError((err, c) => {
  if (err instanceof HTTPException) return err.getResponse();
  // ... generic error handling
});
```
Without this, auth middleware 401 responses get swallowed into 500s.

## Testing infrastructure

- Backend contract tests validate auth (401) and validation (400) without a running DB
- Frontend tests use `happy-dom` with manual global injection (not `@happy-dom/global-registrator`)
- Always call `afterEach(cleanup)` in Testing Library tests — DOM persists in happy-dom
- Test fixtures: `packages/backend/tests/fixtures.ts` — factory functions + token helpers
- Biome overrides: `**/scripts/**` disables `noConsole` and `noExplicitAny` for CLI tools

## AI agent notes

- `.kiro/steering/` and `.kiro/specs/` are authoritative — always align structural changes with those documents rather than inferring architecture solely from current code.
- `.kiro/steering/tech.md` contains explicit constraints on what NOT to introduce. Respect these constraints.
- Prefer mermaid diagrams for architectural or sequence diagrams in documentation.
- Agents are the primary API consumer. Never break the agent API to improve the dashboard experience.
